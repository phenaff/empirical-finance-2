---
title: "Topics in Empirical Finance"
subtitle: "with R and Rmetrics"
author: "Patrick HÃ©naff"
description: "An open access textbook on empirical finance"
cover-image: "img/frontCover.pdf"
github-repo: phenaff/empirical-finance-2
classoption: justified
site: bookdown::bookdown_site
---

# Preface {-}

```{r setup, echo=FALSE, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  cache = TRUE,
  dev.args = list(bg = "transparent")
)
if (knitr:::is_latex_output()) {
  options(knitr.table.format = 'pandoc')
  knitr::opts_chunk$set(dpi = 300)
}
if (knitr:::is_html_output()) {
  knitr::include_graphics('img/social_image.png', dpi = NA)
}

library(tufte)
library(dplyr)
library(ggplot2)
library(ggforce)
library(png)
library(grid)
library(ggraph)
library(igraph)

theme_set(theme_minimal(base_size = 18))
# update_geom_defaults("text", list(size = 7))
# update_geom_defaults("label", list(size = 7))

bookred <- rgb(228, 6, 19, maxColorValue = 255)
bookblue <- rgb(0, 92, 169, maxColorValue = 255)
bookpurple <- rgb(114, 49, 94, maxColorValue = 255)
bookgreen <- rgb(26, 179, 22, maxColorValue = 255)
```

`r newthought("This")`
textbook is about empirical finance, and focusses on the pricing and risk management of financial assets: bonds, futures contracts, and other derivative securities.

The emphasis of this text is empirical. We present models, and verify their relevance by testing them of real data. We emphasize:

\begin{itemize}
\item an incremental approach to model building, starting from simple models, and building upon that foundation to construct more complex models, as needed,
\item a data-driven approach: we will implement all the models that are presented, using the R statistical package and the Rmetrics libraries,
\item the systematic use of simulation as a way of validating modeling decisions.
\end{itemize}

Last but not least, a particular attention is given to model estimation, in order to measure the tradeoff between model complexity and the challenges of a robust calibration.

This course would not be possible without the \RR{} statistical program and without the Rmetrics packages. We extend our deep appreciation to the \RR{} community and to Diethelm Wuertz and the Rmetrics team.


This book is open access (free as in free beer). It's also [open source](https://github.com/phenaff/empirical-finance-2): feel free to clone and submit additions.
You can download a [PDF copy](http://jonathanweisberg.org/vip/_main.pdf) 

<!--chapter:end:index.Rmd-->

# (PART\*) Computational Framework {-} 

This first part is dedicated to the description of the experimental
environment used in this book.

As mentioned earlier, our approach is data-driven and empirical. It is
thus appropriate to start this text with a description of the sources of
data that we will use, and how to fetch publicly available financial
data from the Internet.

In the following chapters, we will make repeated use of the Rmetrics
pricing libraries, and often compare different models applied to the
same data. To facilitate this comparison, the Rmetrics pricing libraries
have been wrapped in a object-oriented framework, which hides most of
the implementation details, and allows us to focus on the key features
of the financial instruments and models. The framework uses the S4
object model [@Genolini2008] of the R language, and is described in
Chapter \@ref(chap:BasicComponents).

Simulation is our tool of choice to explore the features of pricing
models and test their robustness. To that end, we have developped a
framework that facilitates the definition and testing of simple risk
management strategies. The core of this simulation framework is the \class{DataProvider}
class, which is presented in Chapter \@ref(chap:simulation-framework).

In addition to the packages found on CRAN, data sets and code used in the
text have been gathered into three packages:


empfin
: contains all the data sets and several utility functions for simple bond pricing and the manipulation of dates,

fInstrument
: provides the \class{fInstrument} class, that wraps the Rmetrics pricing library and the \class{DataProvider} class, that acts as a container for market data,

DynamicSimulation
: contains tools needed to perform dynamic simulations, such as scenario generators and delta hedging simulators.

<!--chapter:end:Part-1.Rmd-->

# Basic Components {#chap:BasicComponents}

<!-- global knitr options -->

```{r include=FALSE, eval=TRUE, child = '_options.Rmd'}
knitr::opts_chunk$set(size='small')
```

```{r label=load-packages,echo=TRUE,results='hide', message=FALSE}
library(fOptions)
library(fExoticOptions)
library(fInstrument)
library(DynamicSimulation)
library(empfin)
library(plotly)
```

This chapter provides a tutorial and explains the design of the object framework that has been build on top of the Rmetrics library. 
As mentioned earlier, this layer is meant to hide 
most of the implementation details, and allows us to focus on the key features of the 
financial instruments and models. 

The reader is encouraged to work through the examples, but the sections on design and implementation can be skipped. 

The object framework involves two main entities:

  * the \class{fInstrument} class models an abstract financial instrument, and exposes 
    generic methods for computing the net present value (NPV) and the risk 
    indicators (the ``greeks''). With this class, one can perform calculations on portfolio of instruments, without being concerned about the implementation details specific to each type of asset. This will be illustrated below with the detailed description of a delta-hedging algorithm.
  * the \class{DataProvider} class is a container for market data, derived from the built-in \RR{} \code{environment}. It greatly simplifies the signature of pricing functions. Instead of passing as arguments all the necessary market data, we simply pass one \class{DataProvider} argument. The pricing methods fetch the necessary data from the \class{DataProvider}, as needed.

Each entity is now described and illustrated.

## The \class{fInstrument} Class

As mentioned, the purpose of the \class{fInstrument} class is to create a layer of abstraction over the large variety of pricing models found in Rmetrics. With this class, we can express calculation algorithms in a generic manner. This is best explained by an example. 

### Illustration

Consider a portfolio made of two options, a vanilla European call and a binary (cash-or-nothing) option, both written on the same underlying asset. We would like to compute the NPV and delta of this portfolio. Let's contrast the process, first performed with the Rmetrics functions, and then with the \class{fInstrument} class. 

Starting with the Rmetrics functions, you first compute the price and delta of the European call:

```{r ic-0}
p <- vector(mode='numeric', length=2)
d <- vector(mode='numeric', length=2)
```

```{r ic-1}
cp <- 'c'; Spot <- 100; Strike <- 100; Ttm <- 1
int.rate <- .02; div.yield <- .02; sigma <- .3
p[1] <- GBSOption(TypeFlag=cp, S=Spot, X=Strike, Time=Ttm, r=int.rate, b=int.rate-div.yield, 
                  sigma=sigma)@price
d[1] <- GBSGreeks(Selection="delta", TypeFlag=cp, S=Spot, X=Strike, Time=Ttm, r=int.rate, 
                  b=int.rate-div.yield,
                  sigma=sigma)
```

Perform the same calculation for the binary option. The delta is computed 
by finite difference.

```{r ic-2}
K <- 1
p[2] <- CashOrNothingOption(TypeFlag=cp, S=Spot, X=Strike, K=K, Time=Ttm, r=int.rate, 
                            b=int.rate-div.yield,
                            sigma=sigma)@price
h <- Spot*.001
dh <- CashOrNothingOption(TypeFlag=cp, S=c(Spot+h, Spot-h), X=Strike, K=K,
                          Time=Ttm, r=int.rate, b=int.rate-div.yield, 
                          sigma=sigma)@price
d[2] <- diff(dh)/(2*h)
```

Finally, sum both vectors to get the portfolio NPV and delta.

```{r, ic-3}
print(paste('Price:', round(sum(p),2), 'Delta:', round(sum(d),3)))
```

With the \class{fInstrument} class, the calculation steps are quite different.

You first create a vanilla instrument with the \code{fInstrumentFactory} function:
```{r ic-4}
dtExpiry <- myDate('01jan2011')
underlying <- 'IBM'; Strike <- 100; K<-1

b <- fInstrumentFactory("vanilla", quantity=1,
                  params=list(cp='c', strike=Strike,
                  dtExpiry=dtExpiry,
		              underlying=underlying,
                  discountRef='USD.LIBOR', trace=FALSE))
```

Next, use again the \code{fInstrumentfactory} to create the binary option:
```{r ic-5}
v <- fInstrumentFactory("binary", quantity=1,
                  params=list(cp='c', strike=Strike,
                  dtExpiry=dtExpiry, K=K,
		              underlying=underlying,
                  discountRef='USD.LIBOR', trace=FALSE))
```

Insert the relevant market data into a \class{DataProvider} (this will be explained in the next section):
```{r ic-6}
base.env <- DataProvider()
dtCalc <- myDate('01jan2010')
setData(base.env, underlying, 'Price', dtCalc, 100)
setData(base.env, underlying, 'DivYield', dtCalc, div.yield)
setData(base.env, underlying, 'ATMVol', dtCalc, sigma)
setData(base.env, 'USD.LIBOR', 'Yield', dtCalc, int.rate)
```

Construct a portfolio, as a list of \class{fInstrument} objects:
```{r ic-7}
portfolio = c(v, b)
``` 

and finally compute the price and delta of the portfolio:
```{r, ic-8}
price <- sum(sapply(portfolio, function(a) getValue(a, 'Price', dtCalc, base.env)))
delta <- sum(sapply(portfolio, function(a) getValue(a, 'Delta', dtCalc, base.env)))
print(paste('Price:', round(price,2), 'Delta:', round(delta,3)))
```

### Design and Implementation

\class{finstrument} objects are instantiated by the \code{fInstrumentfactory} class 
method, which takes as argument:
\begin{itemize}
  \item the type of instrument being instantiated,
    \item the quantity or nominal amount of the instrument
    \item a list of parameters that define the instrument
\end{itemize}

The \code{fInstrumentFactory} method is simply a switch that delegates the 
object instantiation the the concrete subclasses of \class{fInstrument}. The following code fragment is extracted from the file \code{fInstrument.r} in package \pkg{fInstrument}:
```{r eval=FALSE, echo=TRUE}
fInstrumentFactory <- function(type, quantity, params){
switch(toupper(type),
VANILLA = Vanilla(quantity, params),
BINARY = Binary(quantity, params),
ASIAN = Asian(quantity, params),     
STANDARDBARRIER = StandardBarrier(quantity, params)     
)
}
```

There is only one method defined on \class{fInstrument} objects. This method is \code{getValue}, and takes as argument:
\begin{itemize}
  \item the kind of calculation being requested (price, delta)
    \item the calculation date,
      \item the data container from which the required market data will be fetched.
        \end{itemize}

Again, this method simply delegates to the concrete classes the requested calculation:
```{r eval=FALSE, echo=TRUE}
  setMethod(f="getValue", signature=signature("fInstrument"),
   definition=function(object, selection, dtCalc, env=NULL){
   res <- NULL
   res <- switch(toupper(selection),
   PRICE = object@p(dtCalc, env), 
   DELTA = object@d(dtCalc, env),
   GAMMA = object@g(dtCalc, env),
   VEGA = object@v(dtCalc, env))
   return(res*object@quantity)
})
```

As an illustration, the price calculation for vanilla options is implemented as follows in
\code{Vanilla.r}:
```{r, eval=FALSE, echo=TRUE}
getP <- function(dtCalc, env) {
Spot <- getData(env, Underlying, 'Price', dtCalc)
  s <- getData(env, Underlying, 'ATMVol', dtCalc)
  r <- getData(env, df, 'Yield', dtCalc)
  b <- getData(env, Underlying, 'DivYield', dtCalc)
  t <- tDiff(dtCalc, dtExpiry)
  if (trace) {
    print(paste('Calling GBSOption with Spot=', Spot, 'Strike=', Strike, 't=', t, 'r=', r, 'b=', b, 'sigma=', s))
    }
  GBSOption(TypeFlag=cp, S=Spot, X=Strike, Time=t, r=r, b=b, sigma=s)@price
}
```

The actual calculation being performed by the Rmetrics \code{GBSOption} function. The model can be easily extended to accommodate other instruments.

## The \class{DataProvider} Class

The \code{DataProvider} class is a container of market data, from which the pricing algorithm will fetch the necessary market information, as illustrated in the code fragment above.
We first  describe the representation of market data, then the algorithm for searching data in a \code{DataProvider}.

### The Model for Market Data

The model for market data is strongly inspired by @Fowler1996. To summarize, a piece of market data is modeled as an observed phenomenon on a financial instrument. Therefore, every market data item is identified by three attributes:
\begin{enumerate}
  \item the financial instrument being observed (e.g. a stock)
    \item the observed phenomenon (e.g. the implied volatility, or the price)
      \item the observation date
        \end{enumerate}

In order to optimize storage, the data is stored in a hash table. The first two attributes are combined to created the key, and the data for all observation dates is stored as a time series, with one column for actual data, and many additional columns when performing a simulation.

### The Search Algorithm

The \class{DataProvider} inherits from the built-in \code{environment} class. In particular, it inherits the parent/child relationship: if a \class{DataProvider} has a parent, the data not found in the child environment is fetched from the parent, if possible, or from the grand-parent, and so forth.

This is useful when performing a scenario analysis where only a few variables are modified: The data held constant is stored in the parent scenario, and the modified data is stored in the child scenario which is passed as argument. This scheme is illustrated by the following example.

Let's define a vanilla option:
```{r, tidy=TRUE}
dtExpiry <- myDate('01jan2011'); underlying <- 'IBM'; K<-100
a <- fInstrumentFactory("vanilla", quantity=1,params=list(cp='c', strike=K,
                  dtExpiry=dtExpiry,
underlying=underlying,discountRef='USD.LIBOR', trace=FALSE))
```

and populate a DataProvider with the necessary market data:
```{r, tidy=TRUE}
base.env <- DataProvider()
dtCalc <- myDate('01jan2010')

setData(base.env, underlying, 'Price', dtCalc, 100)
setData(base.env, underlying, 'DivYield', dtCalc, .02)
setData(base.env, underlying, 'ATMVol', dtCalc, .3)
setData(base.env, 'USD.LIBOR', 'Yield', dtCalc, .02)
```

The NPV of the derivative is obtained by:
```{r, collapse=TRUE, comment=NA}
getValue(a, 'Price', dtCalc, base.env)
```

Next, we investigate the relationship between the underlying price and the value of the derivative, by inserting a set of scenarios for the underlying asset price in a child \class{DataProvider}:

```{r}
sce <- t(as.matrix(seq(80, 120, length.out=30)))
sce.env <- DataProvider(parent=base.env)
setData(sce.env, underlying, 'Price', dtCalc, sce)
```

and compute the NPV of the derivative for each scenario. The relationship between the underlying price and the value of the call is illustrated in figure \@ref(fig:sce-plot).
```{r sce-plot, fig.cap="Call Price as a function of spot value. Strike: 100, maturity: 1 Year", fig.scap="Call Price as a function of spot value", out.extra='', fig.margin=TRUE, fig.height=3}
p <- getValue(a, 'Price', dtCalc, sce.env)
plot(sce, p,type='l', lwd=3, xlab='Spot', ylab='Price', bty='n', col='red')
```

<!--chapter:end:simBasicClasses.Rmd-->

# The Simulation Framework {#chap:simulation-framework}

<!-- global knitr options -->

```{r include=FALSE, eval=TRUE, child = '_options.Rmd'}
knitr::opts_chunk$set(size='small')
```


```{r, echo=TRUE,results='hide', message=FALSE}
library(fInstrument)
library(empfin)
library(DynamicSimulation)
```

The simulation framework has two main components:

1.  A simulator, which can generate paths for the variables of interest
    (price of a asset, implied volatility, term structure of interest
    rate, etc.), according to a model that relates the variables to
    stochastic risk factors.

2.  A framework for expressing trading strategies, and in particular
    dynamic hedging policies.

This is again best explained by an example, and we describe next the use
of this framework for running a delta-hedging experiment. The main
elements of the design are discussed afterwards.

## Scenario Simulator

Assume that you want to simulate 500 price paths over a period of one
year, with 100 time steps. The price process will be log-normal with
annual volatility of $30\%$, starting from an initial value of $\$100$.

```{r, label=sim-1, echo=T, warning=FALSE}
  dtStart <- myDate('01jan2010')
  dtEnd <- myDate('01jan2011')
  nbSteps <- 100; nbPaths <- 500
```

Next, define the sequence of simulation dates and the volatility of the simulated log-normal process:

```{r, echo=T, warning=FALSE}
  dtSim <- seq(dtStart, dtEnd, length.out=nbSteps+1)
  sigma <- .3
```

Use a sobol sequence as random number generator, with antithetic variates, standardized to unit variance:

```{r, echo=T, warning=FALSE}
  tSpot <- pathSimulator(dtSim = dtSim, nbPaths=nbPaths,
      innovations.gen=sobolInnovations, path.gen=logNormal,
      path.param = list(mu=0, sigma=sigma), S0=100, antithetic = F,
      standardization = TRUE, trace = FALSE)
  print(head(tSpot[,1:2]))
```

The output of the path simulator is a \class{timeSeries}. A plot of the first few paths is
displayed in figure \@ref(fig:price-plot). The function can generate simulated
values acording to various statistical processes; this is documented in
the vignette of the package.

```{r, label=price-plot, fig.cap="Simulated price paths under a log-normal diffusion process", fig.margin=TRUE, fig.height=4}
  plot(tSpot[,1:50], plot.type='single', ylab='Price', format="%b %d")
```

## A Delta Hedging Experiment

Having generated some scenarios for the stock price, letâs now simulate
the dynamic hedging of a European call option written on this stock,
using the Black-Scholes pricing model, with the implied volatility and
interest rate held constant.

Fist, we define the instrument to be hedged:

```{r, label=delta-hedge-0, echo=T}
  dtExpiry <- dtEnd

  underlying <- 'IBM'; K<-100

  a <- fInstrumentFactory("vanilla", quantity=1,
                    params=list(cp='c', strike=K,
                      dtExpiry=dtExpiry,
                      underlying=underlying,
                      discountRef='USD.LIBOR', trace=FALSE))
```

Next, we define the market data that will be held constant during the
simulation, and insert it in a \class{DataProvider}:

```{r, delta-hedge-2, echo=T, tidy=TRUE}
  base.env <- DataProvider()
  setData(base.env, underlying, 'Price', dtStart, 100)
  setData(base.env, underlying, 'DivYield', dtStart, .02)
  setData(base.env, underlying, 'ATMVol', dtStart, sigma)
  setData(base.env, underlying, 'discountRef', dtStart, 'USD.LIBOR')
  setData(base.env, 'USD.LIBOR', 'Yield', dtStart, .02)
```

At this stage, we can price the asset as of the start date of the
simulation:

```{r, label=value, echo=T}
  p <- getValue(a, 'Price', dtStart, base.env)
```

which gives a value of $p = `r round(p,2) `$.

Next, define the simulation parameters: we want to simulate a dynamic
hedging policy over 500 paths, and 100 time steps per path:

We use a child \class{DataProvider} to store the simulated paths. Data not found in the child \class{DataProvider}
will be searched for (and found) in the parent \code{base.env}.

```{r, delta-hedge-3, echo=T}
  sce.env <- DataProvider(parent=base.env)
  setData(sce.env, underlying, 'Price', time(tSpot), as.matrix(tSpot))
```

We can now run the delta-hedge strategy along each path:

```{r, delta-hedge-4, echo=T}
  assets = list(a)
  res <- deltaHedge(assets, sce.env,
                    params=list(dtSim=time(tSpot),
                    transaction.cost=0),trace=FALSE)
```

The result is a data structure that contains the residual wealth
(hedging error) per scenario and time step. The distribution of hedging
error at expiry is shown in Figure \@ref(fig:delta-hedge-41).

```{r, label=delta-hedge-41, fig.height=5, fig.cap='Distribution of residual wealth at expiry: delta hedge of a 1 year call option', fig.margin=TRUE}
  hist(tail(res$wealth,1), 50, xlab="Residual wealth at expiry", main='')
```

To better illustrate the hedging policy, letâs run a toy example with
few time steps. The function \Rfun{deltaHedge} produces a detailed log of the hedging
policy, which is presented in Table \@ref(tab:delta-hedge-few-samples). For each time step,
the table show:

-   The stock price,

-   the option delta,

-   the option value,

-   the value of the replicating portfolio and the short bond position in that portfolio.

```{r, echo=T}
  dtSim <- time(tSpot)[seq(1, dim(tSpot)[1], 10)]
  res <- deltaHedge(assets, sce.env,
                    params=list(dtSim=dtSim,
                    transaction.cost=0),trace=FALSE)
  sim.table <- makeTable(1, res)
```

```{r, label=delta-hedge-few-samples, echo=FALSE}
  kable(sim.table, "latex", booktabs=T, 
        caption="Simulated value of a call option and its hedge portfolio over time")
```

### Design Considerations

Two design features are worth mentioning.

The generation of the scenarios is independent from the expression of
the dynamic trading strategies. Remember that every data element stored
in a \class{DataProvider} is a \class{timeSeries}. Since all the calculations on \class{fInstrument} are vectorized, there is no
difference between performing a calculation on a scalar, or performing a
simulation on multiple scenarios.

The second aspect is the use of parent/child relationships among
\class{DataProvider} objects. All the market data that is held constant in the simulation is
stored in the parent \class{DataProvider}. The data that changes from simulation to
simulation is stored in the child \class{DataProvider}, and this is the object that is
passed to the simulator. When a piece of data is requested from the
child \class{DataProvider}, the following logic is applied:

1.  First look for the data in the current \class{DataProvider} (the object passed as
    argument to the simulator)

2.  if not found, look for the data in the parent \class{DataProvider}.

3.  and so forth: the logic is recursive.

This behavior is inherited from the built-in \class{environment}.

<!--chapter:end:simSimulationFramework.Rmd-->

